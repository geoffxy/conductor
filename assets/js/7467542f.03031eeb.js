"use strict";(self.webpackChunkconductor=self.webpackChunkconductor||[]).push([[844],{5315:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var s=t(4848),i=t(8453);const r={title:"run_experiment()",id:"run-experiment"},d=void 0,o={id:"task-types/run-experiment",title:"run_experiment()",description:"A run_experiment() task runs the command specified in the run argument. The",source:"@site/docs/task-types/run-experiment.md",sourceDirName:"task-types",slug:"/task-types/run-experiment",permalink:"/conductor/task-types/run-experiment",draft:!1,unlisted:!1,editUrl:"https://github.com/geoffxy/conductor/edit/master/website/docs/task-types/run-experiment.md",tags:[],version:"current",frontMatter:{title:"run_experiment()",id:"run-experiment"},sidebar:"docs",previous:{title:"Task Types",permalink:"/conductor/task-types"},next:{title:"run_command()",permalink:"/conductor/task-types/run-command"}},c={},l=[{value:"Arguments",id:"arguments",level:2},{value:"<code>name</code>",id:"name",level:3},{value:"<code>run</code>",id:"run",level:3},{value:"<code>parallelizable</code>",id:"parallelizable",level:3},{value:"<code>args</code>",id:"args",level:3},{value:"Example",id:"example",level:4},{value:"<code>options</code>",id:"options",level:3},{value:"Example",id:"example-1",level:4},{value:"<code>deps</code>",id:"deps",level:3},{value:"Reserved File Names",id:"reserved-file-names",level:2},{value:"Versioning and Caching Semantics",id:"versioning-and-caching-semantics",level:2},{value:"Projects Using Git",id:"projects-using-git",level:3},{value:"Projects Without Git",id:"projects-without-git",level:3},{value:"Usage Example",id:"usage-example",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"run_experiment(name, run, parallelizable=False, args=[], options={}, deps=[])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"run_experiment()"})," task runs the command specified in the ",(0,s.jsx)(n.code,{children:"run"})," argument. The\ntask's output files are ",(0,s.jsx)(n.a,{href:"#versioning-and-caching-semantics",children:"versioned"})," and\n",(0,s.jsx)(n.a,{href:"/conductor/cli/archive",children:"archivable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["All files that this task produces should be written to the path given in the\n",(0,s.jsx)(n.code,{children:"COND_OUT"})," environment variable. This ensures that (i) your experiment results\ncan be versioned and archived correctly, and (ii) that other tasks that depend\non this task can find this task's produced files."]}),"\n",(0,s.jsx)(n.h2,{id:"arguments",children:"Arguments"}),"\n",(0,s.jsx)(n.h3,{id:"name",children:(0,s.jsx)(n.code,{children:"name"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," String (required)"]}),"\n",(0,s.jsxs)(n.p,{children:["The task's name. This name must be unique within the task's ",(0,s.jsx)(n.code,{children:"COND"})," file. A task\nname can only contain letters, numbers, hyphens (",(0,s.jsx)(n.code,{children:"-"}),"), and underscores (",(0,s.jsx)(n.code,{children:"_"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"run",children:(0,s.jsx)(n.code,{children:"run"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," String (required)"]}),"\n",(0,s.jsxs)(n.p,{children:["The command to execute when running this task. This command will be executed\nusing ",(0,s.jsx)(n.code,{children:"bash"}),", with the location of the task's ",(0,s.jsx)(n.code,{children:"COND"})," file as the shell's working\ndirectory. In other words, any relative paths in the command will be interpreted\nas relative to the directory containing the task's ",(0,s.jsx)(n.code,{children:"COND"})," file."]}),"\n",(0,s.jsxs)(n.p,{children:["Conductor uses the exit code of the command to determine whether it succeeded or\nfailed. If the command succeeds, it should exit with an exit code of ",(0,s.jsx)(n.code,{children:"0"}),".\nConductor interprets any non-zero exit code as a failure. If a task fails, it\nprevents any other tasks that depend on it from executing (see the reference for\n",(0,s.jsx)(n.a,{href:"/conductor/cli/run",children:(0,s.jsx)(n.code,{children:"cond run"})}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"parallelizable",children:(0,s.jsx)(n.code,{children:"parallelizable"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Boolean (default: ",(0,s.jsx)(n.code,{children:"False"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["If set to ",(0,s.jsx)(n.code,{children:"True"}),", Conductor may launch this task while other ",(0,s.jsx)(n.code,{children:"parallelizable"}),"\ntasks are running. You should set this argument to ",(0,s.jsx)(n.code,{children:"True"})," if it is okay for this\ntask to execute while other tasks are also running."]}),"\n",(0,s.jsxs)(n.p,{children:["By default, tasks are not ",(0,s.jsx)(n.code,{children:"parallelizable"}),", and so Conductor will not launch a\nnew task until the previously launched task has completed (or failed)."]}),"\n",(0,s.jsx)(n.h3,{id:"args",children:(0,s.jsx)(n.code,{children:"args"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," List of primitive types (default: ",(0,s.jsx)(n.code,{children:"[]"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["A list of ordered arguments that should be passed to the command string\nspecified in ",(0,s.jsx)(n.code,{children:"run"}),". The arguments will be passed to the command in the order\nthey are listed in ",(0,s.jsx)(n.code,{children:"args"}),". The primitive types supported in ",(0,s.jsx)(n.code,{children:"args"})," are strings,\nBooleans, integers, and floating point numbers."]}),"\n",(0,s.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'run_experiment(\n  name="example",\n  run="./run.sh",\n  args=["arg1", "arg2", 123, True, 0.3],\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Conductor will execute the task shown above by running ",(0,s.jsx)(n.code,{children:"./run.sh arg1 arg2 123 true 0.3"})," in ",(0,s.jsx)(n.code,{children:"bash"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"options",children:(0,s.jsx)(n.code,{children:"options"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Dictionary mapping string keys to primitive values (default: ",(0,s.jsx)(n.code,{children:"{}"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["A map of string keys to primitive values that should be passed to the command\nstring specified in ",(0,s.jsx)(n.code,{children:"run"}),'. Conductor treats these options as command line\n"flags" and will pass them to the ',(0,s.jsx)(n.code,{children:"run"})," command using ",(0,s.jsx)(n.code,{children:"--key=value"})," syntax. Like\n",(0,s.jsx)(n.code,{children:"args"}),", the primitive types supported in ",(0,s.jsx)(n.code,{children:"options"})," are strings, Booleans,\nintegers, and floating point numbers. When ",(0,s.jsx)(n.code,{children:"args"})," and ",(0,s.jsx)(n.code,{children:"options"})," are both\nnon-empty, ",(0,s.jsx)(n.code,{children:"args"})," are always passed first before ",(0,s.jsx)(n.code,{children:"options"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'run_experiment(\n  name="example",\n  run="./run.sh",\n  args=["arg1"],\n  options={\n    "foo": 3,\n    "bar": True,\n  },\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Conductor will execute the task shown above by running ",(0,s.jsx)(n.code,{children:"./run.sh arg1 --foo=3 --bar=true"})," in ",(0,s.jsx)(n.code,{children:"bash"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"deps",children:(0,s.jsx)(n.code,{children:"deps"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," List of task identifiers (default: ",(0,s.jsx)(n.code,{children:"[]"}),")"]}),"\n",(0,s.jsx)(n.p,{children:"A list of task identifiers that this task should depend on. Conductor will\nensure that all dependencies execute successfully before launching this task."}),"\n",(0,s.jsxs)(n.p,{children:["When depending on tasks defined in the same ",(0,s.jsx)(n.code,{children:"COND"})," file, you can just specify\nthe task's name prefixed by a colon (e.g., ",(0,s.jsx)(n.code,{children:":compile"})," would refer to a task\nnamed ",(0,s.jsx)(n.code,{children:"compile"})," defined in the same file). If you need to depend on a task\ndefined in a different ",(0,s.jsx)(n.code,{children:"COND"})," file, you must specify the fully qualified task\nidentifier (e.g., ",(0,s.jsx)(n.code,{children:"//experiments:benchmark"})," would refer to a task named\n",(0,s.jsx)(n.code,{children:"benchmark"})," defined in the ",(0,s.jsx)(n.code,{children:"COND"})," file in the ",(0,s.jsx)(n.code,{children:"experiments"})," directory)."]}),"\n",(0,s.jsx)(n.h2,{id:"reserved-file-names",children:"Reserved File Names"}),"\n",(0,s.jsxs)(n.p,{children:["Conductor records additional metadata about ",(0,s.jsx)(n.code,{children:"run_experiment()"})," tasks in special\nfiles under the path given by ",(0,s.jsx)(n.code,{children:"$COND_OUT"}),". Your executable should not produce\nfiles with the same names because they will be overwritten."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"File Name"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"args.json"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["The arguments passed to the ",(0,s.jsx)(n.code,{children:"run"})," command using ",(0,s.jsx)(n.code,{children:"args"}),", serialized to JSON."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"options.json"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["The options passed to the ",(0,s.jsx)(n.code,{children:"run"})," command using ",(0,s.jsx)(n.code,{children:"options"}),", serialized to JSON."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"stderr.log"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["A log of the ",(0,s.jsx)(n.code,{children:"run"})," command's output to standard error."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"stdout.log"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["A log of the ",(0,s.jsx)(n.code,{children:"run"})," command's output to standard out."]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"versioning-and-caching-semantics",children:"Versioning and Caching Semantics"}),"\n",(0,s.jsxs)(n.p,{children:["Conductor versions ",(0,s.jsx)(n.code,{children:"run_experiment()"})," tasks' outputs. When running a\n",(0,s.jsx)(n.code,{children:"run_experiment()"}),' task, Conductor will check to see if a previous compatible\noutput version exists. If so, it will use the cached results of the "most\ncompatible" version instead of running the task again (unless otherwise\nspecified, see ',(0,s.jsx)(n.a,{href:"/conductor/cli/run",children:(0,s.jsx)(n.code,{children:"cond run"})}),'). This section describes the semantics\nof output version "compatibility."']}),"\n",(0,s.jsx)(n.h3,{id:"projects-using-git",children:"Projects Using Git"}),"\n",(0,s.jsxs)(n.p,{children:["Whenever a ",(0,s.jsx)(n.code,{children:"run_experiment()"})," task executes, Conductor records the repository's\ncurrent commit hash and associates it with the outputs. Conductor then\ndetermines a task output's compatibility based on the task output's commit hash\nand the repository's current commit (i.e., the value of ",(0,s.jsx)(n.code,{children:"HEAD"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["The most compatible version is the version whose commit is both (i) an ancestor\nof the current commit (i.e., an ancestor of ",(0,s.jsx)(n.code,{children:"HEAD"}),'), and (ii) "closest" to the\ncurrent commit. Conductor defines closeness as the number of commits separating\nthe repository\'s current commit (',(0,s.jsx)(n.code,{children:"HEAD"}),') and the task version\'s commit. If there\nare multiple closest task versions, Conductor selects the most recent one as\ndetermined by execution timestamp. If there are no "compatible" outputs,\nConductor will execute the task.']}),"\n",(0,s.jsx)(n.h3,{id:"projects-without-git",children:"Projects Without Git"}),"\n",(0,s.jsxs)(n.p,{children:["If your project is not managed using Git (or has Conductor's Git integration\nexplicitly disabled), Conductor will always select the most ",(0,s.jsx)(n.em,{children:"recent"})," version of\nthe task's outputs. Recency is determined by when the task was executed (i.e., a\ntimestamp). If there are no outputs available, Conductor will execute the task."]}),"\n",(0,s.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="COND"',children:'run_experiment(\n  name="benchmark",\n  run="./run_benchmark.sh",\n  parallelizable=False,\n  args=["my_dataset.csv"],\n  options={\n    "threads": 3,\n  },\n  deps=[\n    ":compile",\n  ],\n)\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function d(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);